{"version":3,"sources":["../lib/syntax.ts"],"sourcesContent":["// syntax.ts — Unified wrapper that streamlines syntax creation\n//             with integrated lexer-parser coordination, LSP support,\n//             and enhanced linting capabilities.\n//\n// repo   : https://github.com/je-es/syntax\n// author : https://github.com/maysara-elshewehy\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as lexer  from '@je-es/lexer';\n    import * as parser from '@je-es/parser';\n    import * as AST from '@je-es/ast';\n\n    export * as lexer  from '@je-es/lexer';\n    export * as parser from '@je-es/parser';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export interface KeywordDoc {\n        signature           : string;\n        description         : string;\n        example?            : string;\n    }\n\n    export interface LSPKeywords {\n        declarations        : string[];\n        types               : string[];\n        controlFlow         : string[];\n        modifiers           : string[];\n        operators           : string[];\n        literals            : string[];\n        builtins            : string[];\n    }\n\n    export interface LSPConfig {\n        keywords            : LSPKeywords;\n        keywordDocs         : { [key: string]: KeywordDoc };\n        builtinDocs         : { [key: string]: string };\n        triggerCharacters?  : string[];\n        fileExtension?      : string;\n    }\n\n    export interface BuiltinConfig {\n        types               : Builtin[]; // as type\n        functions           : Builtin[]; // as function\n    }\n\n    export interface Builtin {\n        stmt                : AST.StmtNode;\n        mode                : 'type' | 'function';\n        metadata?           : {\n            [key: string]: any\n        };\n    }\n\n    export type DefaultArg = { ind: number, value: AST.ExprNode };\n\n    export interface SyntaxConfig {\n        name                : string;\n        version             : string;\n        lexer               : lexer.Rules;\n        parser              : parser.Rule[];\n        settings            : parser.ParserSettings;\n        lsp?                : LSPConfig;\n        builtin             : BuiltinConfig;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class Syntax {\n        public config       : SyntaxConfig;\n        public parser       : parser.Parser;\n        public lsp?         : LSPConfig;\n\n        constructor(config: SyntaxConfig) {\n            this.config     = config;\n            this.parser     = new parser.Parser(config.parser, config.settings);\n            this.lsp        = config.lsp;\n        }\n\n        parse(input: string): parser.ParseResult {\n            const tokens = lexer.tokenize(input, this.config.lexer);\n            return this.parser.parse(tokens);\n        }\n\n        lint(input: string): parser.ParseError[] {\n            const tokens = lexer.tokenize(input, this.config.lexer);\n            return this.parser.parse(tokens).errors;\n        }\n\n        from(ruleName: string, debug: parser.DebugLevel | null = null): Syntax {\n            const newConfig = { ...this.config };\n            if (debug !== null) {\n                newConfig.settings.debug = debug;\n            }\n            newConfig.settings.startRule = ruleName;\n            return new Syntax(newConfig);\n        }\n\n        getLSPKeywords(): LSPKeywords | undefined {\n            return this.lsp?.keywords;\n        }\n\n        getAllKeywords(): string[] {\n            if (!this.lsp?.keywords) return [];\n            const { declarations, types, controlFlow, modifiers, operators, literals } = this.lsp.keywords;\n            return [...declarations, ...types, ...controlFlow, ...modifiers, ...operators, ...literals];\n        }\n\n        getKeywordDoc(keyword: string): KeywordDoc | undefined {\n            return this.lsp?.keywordDocs?.[keyword];\n        }\n\n        getBuiltinDoc(builtin: string): string | undefined {\n            return this.lsp?.builtinDocs?.[builtin];\n        }\n\n        isKeyword(str: string): boolean {\n            if (!this.lsp?.keywords) return false;\n            const all = this.getAllKeywords();\n            return all.includes(str);\n        }\n\n        isBuiltin(str: string): boolean {\n            if (!this.lsp?.keywords) return false;\n            return this.lsp.keywords.builtins.includes(str);\n        }\n    }\n\n    export function create(config: SyntaxConfig): Syntax {\n        return new Syntax(config);\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝"],"mappings":";;;;;;;;;;;;;;;;;;AAaI,YAAY,WAAY;AACxB,YAAY,YAAY;AAGxB,YAAYA,YAAY;AACxB,YAAYC,aAAY;AA+DjB,IAAM,SAAN,MAAM,QAAO;AAAA,EAKhB,YAAY,QAAsB;AAC9B,SAAK,SAAa;AAClB,SAAK,SAAa,IAAW,cAAO,OAAO,QAAQ,OAAO,QAAQ;AAClE,SAAK,MAAa,OAAO;AAAA,EAC7B;AAAA,EAEA,MAAM,OAAmC;AACrC,UAAM,SAAe,eAAS,OAAO,KAAK,OAAO,KAAK;AACtD,WAAO,KAAK,OAAO,MAAM,MAAM;AAAA,EACnC;AAAA,EAEA,KAAK,OAAoC;AACrC,UAAM,SAAe,eAAS,OAAO,KAAK,OAAO,KAAK;AACtD,WAAO,KAAK,OAAO,MAAM,MAAM,EAAE;AAAA,EACrC;AAAA,EAEA,KAAK,UAAkB,QAAkC,MAAc;AACnE,UAAM,YAAY,mBAAK,KAAK;AAC5B,QAAI,UAAU,MAAM;AAChB,gBAAU,SAAS,QAAQ;AAAA,IAC/B;AACA,cAAU,SAAS,YAAY;AAC/B,WAAO,IAAI,QAAO,SAAS;AAAA,EAC/B;AAAA,EAEA,iBAA0C;AA/GlD;AAgHY,YAAO,UAAK,QAAL,mBAAU;AAAA,EACrB;AAAA,EAEA,iBAA2B;AAnHnC;AAoHY,QAAI,GAAC,UAAK,QAAL,mBAAU,UAAU,QAAO,CAAC;AACjC,UAAM,EAAE,cAAc,OAAO,aAAa,WAAW,WAAW,SAAS,IAAI,KAAK,IAAI;AACtF,WAAO,CAAC,GAAG,cAAc,GAAG,OAAO,GAAG,aAAa,GAAG,WAAW,GAAG,WAAW,GAAG,QAAQ;AAAA,EAC9F;AAAA,EAEA,cAAc,SAAyC;AAzH/D;AA0HY,YAAO,gBAAK,QAAL,mBAAU,gBAAV,mBAAwB;AAAA,EACnC;AAAA,EAEA,cAAc,SAAqC;AA7H3D;AA8HY,YAAO,gBAAK,QAAL,mBAAU,gBAAV,mBAAwB;AAAA,EACnC;AAAA,EAEA,UAAU,KAAsB;AAjIxC;AAkIY,QAAI,GAAC,UAAK,QAAL,mBAAU,UAAU,QAAO;AAChC,UAAM,MAAM,KAAK,eAAe;AAChC,WAAO,IAAI,SAAS,GAAG;AAAA,EAC3B;AAAA,EAEA,UAAU,KAAsB;AAvIxC;AAwIY,QAAI,GAAC,UAAK,QAAL,mBAAU,UAAU,QAAO;AAChC,WAAO,KAAK,IAAI,SAAS,SAAS,SAAS,GAAG;AAAA,EAClD;AACJ;AAEO,SAAS,OAAO,QAA8B;AACjD,SAAO,IAAI,OAAO,MAAM;AAC5B;","names":["lexer","parser"]}