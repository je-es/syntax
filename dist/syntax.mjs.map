{"version":3,"sources":["../lib/syntax.ts","../../parser/lib/result.ts","../../parser/lib/types.ts","../../parser/lib/core.ts","../../parser/lib/parser.ts"],"sourcesContent":["// syntax.ts — Unified wrapper that streamlines syntax creation\n//             with integrated lexer-parser coordination, LSP support,\n//             and enhanced linting capabilities.\n//\n// repo   : https://github.com/je-es/syntax\n// author : https://github.com/maysara-elshewehy\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as lexer  from '@je-es/lexer';\n    import * as parser from '@je-es/parser';\n\n    export * as lexer  from '@je-es/lexer';\n    export * as parser from '@je-es/parser';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export interface SyntaxConfig {\n        name        : string;\n        version     : string;\n        lexer       : lexer.Rules;\n        parser      : parser.Rule[];\n        settings    : parser.ParserSettings;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Represents a syntax with its lexer, parser, and settings.\n    */\n    export class Syntax {\n        public config: SyntaxConfig;\n        public parser: parser.Parser;\n\n        constructor(config: SyntaxConfig) {\n            this.config = config;\n            this.parser = new parser.Parser(config.parser, config.settings);\n        }\n\n        parse(input: string): parser.ParseResult {\n            const tokens = lexer.tokenize(input, this.config.lexer);\n            return this.parser.parse(tokens);\n        }\n\n        lint(input: string): parser.ParseError[] {\n            const tokens = lexer.tokenize(input, this.config.lexer);\n            return this.parser.parse(tokens).errors;\n        }\n\n        from(ruleName: string, debug: parser.DebugLevel | null = null): Syntax {\n            const newConfig = { ...this.config };\n            if (debug !== null) {\n                newConfig.settings.debug = debug;\n            }\n            newConfig.settings.startRule = ruleName;\n            return new Syntax(newConfig);\n        }\n    }\n\n    /**\n     * Create a new syntax object with the given configuration.\n     *\n     * @param config - The configuration object for the syntax, containing the\n     *                 lexer rules, parser rules, and parser settings.\n     * @returns A new syntax object.\n     */\n    export function create(config: SyntaxConfig): Syntax {\n        return new Syntax(config);\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// result.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as Types from './types';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type ResultStatus        = 'unset' | 'failed' | 'passed';\n    export type ResultMode          = 'unset' | 'token' | 'optional' | 'choice' | 'repeat' | 'seq' | 'custom';\n\n    export interface TokenSource {\n        source_kind     : 'token-source';\n\n        kind            : string;\n        value          ?: string;\n        span           ?: Types.Span;\n    }\n\n    export interface OptionalSource {\n        source_kind     : 'optional-source';\n\n        result          : Result | null;\n    }\n\n    export interface ChoiceSource {\n        source_kind     : 'choice-source';\n\n        atIndex         : number;\n        result          : Result | null;\n    }\n\n    export interface RepeatSource {\n        source_kind     : 'repeat-source',\n\n        result          : Result[];\n    }\n\n    export interface SequenceSource {\n        source_kind     : 'sequence-source',\n\n        result          : Result[];\n    }\n\n    export interface CustomSource {\n        source_kind     : 'custom-source',\n\n        tag             : string;\n        data            : unknown;\n    }\n\n    export type ResultSource = TokenSource | OptionalSource | ChoiceSource | RepeatSource | SequenceSource | CustomSource | null;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class Result {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            // Core data\n            public span         : Types.Span            = { start: -99, end: -99 };\n            public status       : ResultStatus          = 'unset';\n            public source       : ResultSource          = null;\n            public mode         : ResultMode            = 'unset';\n            public errors       : Types.ParseError[]    = [];\n\n\n            // Initialization\n            constructor(status: ResultStatus, source: ResultSource | null, mode: ResultMode, span: Types.Span) {\n                this.status     = status;\n                this.source     = source;\n                this.mode       = mode;\n                this.span       = span;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────────── FACTORY ────────────────────────────┐\n\n            clone() : Result {\n                const res = new Result(this.status, this.source, this.mode, this.span);\n                res.errors = [...this.errors];\n                return res;\n            }\n\n            static create(status: ResultStatus, source: ResultSource | null, mode: ResultMode, span: Types.Span) : Result {\n                return new Result(status, source, mode, span);\n            }\n\n            static createAsToken(status: ResultStatus, source: Types.Token | null, span: Types.Span) : Result {\n                const newSource : TokenSource = {\n                    source_kind : 'token-source',\n                    kind        : source?.kind ?? 'unset',\n                    value       : source?.value ?? undefined,\n                    span        : span,\n                };\n                return Result.create(status, newSource, 'token', span);\n            }\n\n            static createAsOptional(status: ResultStatus, source: Result | null, span: Types.Span) : Result {\n                const newSource : OptionalSource = {\n                    source_kind : 'optional-source',\n                    result      : source\n                };\n\n                return Result.create(status, newSource, 'optional', span);\n            }\n\n            static createAsChoice(status: ResultStatus, source: Result | null, index: number, span: Types.Span) : Result {\n                const newSource : ChoiceSource = {\n                    source_kind : 'choice-source',\n                    atIndex     : index,\n                    result      : source\n                };\n\n                return Result.create(status, newSource, 'choice', span);\n            }\n\n            static createAsRepeat(status: ResultStatus, source: Result[] | null, span: Types.Span) : Result {\n                const newSource : RepeatSource = {\n                    source_kind : 'repeat-source',\n                    result      : source ?? []\n                };\n\n                return Result.create(status, newSource, 'repeat', span);\n            }\n\n            static createAsSequence(status: ResultStatus, source: Result[] | null, span: Types.Span) : Result {\n                const newSource : SequenceSource = {\n                    source_kind : 'sequence-source',\n                    result      : source ?? []\n                };\n\n                return Result.create(status, newSource, 'seq', span);\n            }\n\n            static createAsCustom(status: ResultStatus, name: string, data: unknown, span: Types.Span) : Result {\n                const newSource : CustomSource = {\n                    source_kind : 'custom-source',\n                    tag         : name,\n                    data        : data,\n                };\n\n                return Result.create(status, newSource, 'custom', span);\n            }\n\n            withError(err: Types.ParseError) : Result {\n                this.errors.push(err);\n                return this;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── IS_X ──────────────────────────────┐\n\n            isPassed() : boolean {\n                return this.status === 'passed';\n            }\n\n            isFullyPassed() : boolean {\n                if(!this.isPassed()) return false;\n                if(this.isOptional() && !this.isOptionalPassed()) return false;\n                return true;\n            }\n\n            isFailed() : boolean {\n                return this.status === 'failed';\n            }\n\n            isUnset() : boolean {\n                return this.status === 'unset';\n            }\n\n            isToken() : boolean {\n                return this.mode === 'token';\n            }\n\n            isOptional() : boolean {\n                return this.mode === 'optional';\n            }\n\n            isOptionalPassed() : boolean {\n                return this.isOptional() && (this.source as OptionalSource).result !== null;\n            }\n\n            isChoice() : boolean {\n                return this.mode === 'choice';\n            }\n\n            isRepeat() : boolean {\n                return this.mode === 'repeat';\n            }\n\n            isSequence() : boolean {\n                return this.mode === 'seq';\n            }\n\n            isCustom(tag?: string) : boolean {\n                if(this.mode === 'custom') {\n                    if(tag) {\n                        return (this.source as CustomSource).tag == tag;\n                    } else return true;\n                }\n\n                return false;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌────────────────────────────── GETTERS ─────────────────────────────┐\n\n            getTokenKind() : string | undefined {\n                if(this.isToken()) {\n                    return (this.source as TokenSource).kind;\n                }\n\n                return undefined;\n            }\n\n            getTokenValue() : string | null | undefined {\n                if(this.isToken()) {\n                    if((this.source as TokenSource).value === undefined) {\n                        return null;\n                    }\n\n                    return (this.source as TokenSource).value;\n                }\n\n                return undefined;\n            }\n\n            getTokenSpan() : Types.Span | undefined {\n                if(this.isToken()) {\n                    return (this.source as TokenSource).span;\n                }\n\n                return undefined;\n            }\n\n            getTokenData() : Types.Token | undefined {\n                if(this.isToken()) {\n                    return {\n                        kind  : (this.source as TokenSource).kind,\n                        value : (this.source as TokenSource).value!,\n                        span  : (this.source as TokenSource).span!,\n                    };\n                }\n\n                return undefined;\n            }\n\n            getOptionalResult() : Result | null | undefined {\n                if(this.isOptionalPassed()) {\n                    return (this.source as OptionalSource).result;\n                }\n\n                return undefined;\n            }\n\n            getChoiceIndex() : number | undefined {\n                if(this.isChoice()) {\n                    return (this.source as ChoiceSource).atIndex;\n                }\n\n                return undefined;\n            }\n\n            getChoiceResult() : Result | null | undefined {\n                if(this.isChoice()) {\n                    return (this.source as ChoiceSource).result;\n                }\n\n                return undefined;\n            }\n\n            getRepeatCount() : number | undefined {\n                if(this.isRepeat()) {\n                    return (this.source as RepeatSource).result.length;\n                }\n\n                return undefined;\n            }\n\n            getRepeatResult() : Result[] | undefined {\n                if(this.isRepeat()) {\n                    return (this.source as RepeatSource).result;\n                }\n\n                return undefined;\n            }\n\n            getSequenceCount() : number | undefined {\n                if(this.isSequence()) {\n                    return (this.source as SequenceSource).result.length;\n                }\n\n                return undefined;\n            }\n\n            getSequenceResult() : Result[] | undefined {\n                if(this.isSequence()) {\n                    return (this.source as SequenceSource).result;\n                }\n\n                return undefined;\n            }\n\n            getCustomData() : unknown | undefined {\n                if(this.isCustom()) {\n                    return (this.source as CustomSource).data;\n                }\n\n                return undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            hasErrors() : boolean {\n                return this.errors.length > 0;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n","// types.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Parser } from './core';\n    import { Result } from './result';\n    \n    export { Result };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export interface Token {\n        kind            : string;\n        value           : string | null;\n        span            : Span;\n    }\n\n    export interface MiniToken {\n        kind            : string;\n        value           : string | null;\n    }\n\n    export interface Span {\n        start           : number;\n        end             : number;\n    }\n\n    export interface Pattern {\n        type            : 'token' | 'rule' | 'repeat' | 'choice' | 'seq' | 'optional';\n        silent          : boolean;\n        value          ?: string;       // for token\n        name           ?: string;       // for rule and token\n        min            ?: number;       // for repeat\n        max            ?: number;       // for repeat\n        patterns       ?: Pattern[];    // for seq, choice, optional, repeat\n        separator      ?: Pattern;      // for repeat\n        pattern        ?: Pattern;      // for optional\n    }\n\n    export interface ErrorHandler {\n        cond            : number | ((parser: Parser, opt: { failedAt: number, tokenIndex: number, force?: boolean, prevRule?: string, prevInnerRule?: string }) => boolean);\n        msg             : string;\n        code?           : string;\n    }\n\n    export interface RecoveryStrategy {\n        type            : 'skipUntil';\n        tokens?         : string[];\n        token?          : string;\n    }\n\n    export type BuildFunction = (matches: Result, parser: Parser) => Result;\n\n    export interface Rule {\n        name            : string;\n        pattern         : Pattern;\n        options?        : {\n            build?      : BuildFunction;\n            errors?     : ErrorHandler[];\n            recovery?   : RecoveryStrategy;\n            ignored?    : string[];\n            silent?     : boolean;\n        };\n    }\n\n    export type Rules = Rule[];\n\n    export interface ParseStatistics {\n        tokensProcessed : number;\n        rulesApplied    : number;\n        errorsRecovered : number;\n        parseTimeMs     : number;\n    }\n\n    export interface AstNode {\n        rule            : string;\n        span            : Span;\n        data           ?: unknown;\n    }\n\n    export interface ParseError {\n        msg             : string;\n        code            : string;\n        span            : Span;\n        failedAt        : number;\n        tokenIndex      : number;\n        startIndex      : number;\n        prevRule        : string;\n        prevInnerRule?  : string;\n    }\n\n    export interface ParseResult {\n        ast             : Result[];\n        errors          : ParseError[];\n        statistics?     : ParseStatistics;\n    }\n\n    export type DebugLevel = 'off' | 'errors' | 'rules' | 'patterns' | 'tokens' | 'verbose';\n\n    export interface ParserSettings {\n        startRule       : string;\n        errorRecovery?  : {\n            mode?       : 'strict' | 'resilient';\n            maxErrors?  : number;\n        };\n        ignored?        : string[];\n        debug?          : DebugLevel;\n        maxDepth?       : number;\n        maxCacheSize?   : number;\n    }\n\n    export const ERRORS = {\n        // Core parsing errors\n        LEXICAL_ERROR           : 'LEXICAL_ERROR',\n        TOKEN_EXPECTED_EOF      : 'TOKEN_EXPECTED_EOF',\n        TOKEN_MISMATCH          : 'TOKEN_MISMATCH',\n        RULE_FAILED             : 'RULE_FAILED',\n        BUILD_FUNCTION_FAILED   : 'BUILD_FUNCTION_FAILED',\n        REPEAT_MIN_NOT_MET      : 'REPEAT_MIN_NOT_MET',\n        SEQUENCE_FAILED         : 'SEQUENCE_FAILED',\n        CUSTOM_ERROR            : 'CUSTOM_ERROR',\n\n        // Choice and alternatives\n        CHOICE_ALL_FAILED       : 'CHOICE_ALL_FAILED',\n\n        // System errors\n        FATAL_ERROR             : 'FATAL_ERROR',\n        UNKNOWN_ERROR           : 'UNKNOWN_ERROR',\n\n        // Recovery and validation\n        RECOVERY_CUSTOM         : 'RECOVERY_CUSTOM',\n    } as const;\n\n    export interface MemoEntry {\n        result         ?: Result | null;\n        newIndex       ?: number;\n        cachedAt       ?: number;\n        silentContext  ?: boolean;\n        errorCount     ?: number;\n        hit            ?: boolean;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// core.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as Types from './types';\n    import { Result } from './result';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class Parser {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            // Core data\n            public rules                    : Map<string, Types.Rule>;\n            public settings                 : Types.ParserSettings;\n\n            // State\n            public tokens                   : Types.Token[] = [];\n            public ast                      : Result[] = [];\n            public errors                   : Types.ParseError[] = [];\n            public index                    : number = 0;\n            public depth                    : number = 0;\n            private rootStartIndex          : number = 0;\n\n            // Debug & stats\n            private debugLevel              : Types.DebugLevel;\n            private indentLevel             : number = 0;\n            public stats                    : Types.ParseStatistics;\n            public startTime                : number = 0;\n            public errorSeq                 : number = 0;\n\n            // Performance\n            public memoCache                : Map<string, Types.MemoEntry> = new Map<string, Types.MemoEntry>();\n            public ignoredSet               : Set<string> = new Set<string>();\n            public memoHits                 : number = 0;\n            public memoMisses               : number = 0;\n\n            // Context tracking (TODO: review it.)\n            private silentContextStack      : boolean[]     = [];\n            public lastVisitedIndex         : number        = 0;\n            public lastHandledRule          : string        = 'unknown';\n            public ruleStack                : string[]      = [];\n            public patternStack             : string[]      = [];\n            public lastInnerRule            : string        = 'unknown';\n            public lastCompletedRule        : string        = 'unknown';\n            public successfulRules          : string[]      = [];\n            private globalSuccessRules      : string[]      = [];\n            private lastLeafRule            : string        = 'unknown';\n\n            // Initialization\n            constructor(rules: Types.Rule[], settings?: Types.ParserSettings) {\n                this.rules          = new Map(rules.map(rule => [rule.name, rule]));\n                this.settings       = this.normalizeSettings(settings);\n                this.debugLevel     = this.settings.debug!;\n                this.ignoredSet     = new Set(this.settings.ignored!);\n\n                this.stats = { tokensProcessed: 0, rulesApplied: 0, errorsRecovered: 0, parseTimeMs: 0 };\n\n                const grammarIssues = this.validateGrammar();\n                if (grammarIssues.length > 0) {\n                    throw new Error(`Grammar validation failed: ${grammarIssues.join(', ')}`);\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            parse(tokens: Types.Token[]): Types.ParseResult {\n\n                this.resetState(tokens);\n                this.startTime = Date.now();\n                this.log('rules', `🚀 Parse started: ${tokens.length} tokens`);\n\n                // Early validation\n                if (!tokens?.length) {return { ast: [], errors: [] };}\n\n                const errorToken = tokens.find(token => token.kind === 'error');\n                if (errorToken) {\n                    return {\n                        ast: [],\n                        errors: [this.createError(Types.ERRORS.LEXICAL_ERROR, `Unexpected token '${errorToken.value}'`, Parser.hanldeErrorSpan(errorToken.span), 0, 0, this.lastHandledRule)]\n                    };\n                }\n\n                try {\n                    const startRule = this.rules.get(this.settings.startRule);\n                    if (!startRule) {\n                        throw new Error(`Start rule '${this.settings.startRule}' not found`);\n                    }\n\n                    this.skipIgnored();\n                    this.parseWithRecovery(startRule);\n                    this.skipIgnored();\n                } catch (err: unknown) {\n                    this.handleFatalError(err);\n                }\n\n                this.stats.parseTimeMs = Date.now() - this.startTime;\n                this.log('rules', `✅ Parse completed: ${this.ast.length} nodes, ${this.errors.length} errors (${this.stats.parseTimeMs}ms)`);\n                this.log('verbose', `📊 Memo stats: ${this.memoHits} hits, ${this.memoMisses} misses, ${this.memoCache.size} cached entries`);\n\n                return {\n                    ast: this.ast,\n                    errors: this.errors,\n                    statistics: this.stats\n                };\n            }\n\n            private parseWithRecovery(startRule: Types.Rule): void {\n                const maxErrors = this.settings.errorRecovery!.maxErrors!;\n                let consecutiveErrors = 0;\n\n                while (this.index < this.tokens.length && (maxErrors === 0 || this.errors.length < maxErrors)) {\n                    const beforeIndex = this.index;\n                    this.rootStartIndex = beforeIndex; // Set root start index\n\n                    try {\n                        const result = this.parsePattern(startRule.pattern, startRule);\n\n                        if (result.status === 'passed') {\n                            const processed = startRule.options?.build\n                                ? this.safeBuild(startRule.options.build, result)\n                                : result;\n\n                            if (processed !== null) {\n                                this.ast.push(processed);\n                            }\n                        }\n\n                        consecutiveErrors = 0;\n\n                        if (this.index >= this.tokens.length || this.index === beforeIndex) {\n                            break;\n                        }\n                    } catch (error: unknown) {\n                        consecutiveErrors++;\n\n                        const parseError = this.normalizeError(error, this.getCurrentSpan());\n                        this.addError(parseError);\n\n                        // Better error recovery\n                        if (this.settings.errorRecovery!.mode === 'resilient') {\n                            this.applyRecovery(startRule, beforeIndex);\n\n                            // Force progress if we're stuck\n                            if (this.index === beforeIndex && this.index < this.tokens.length) {\n                                this.index++;\n                            }\n                        } else {\n                            // In strict mode, stop after first error\n                            break;\n                        }\n\n                        if (consecutiveErrors > 10) {\n                            break;\n                        }\n                    }\n\n                    this.skipIgnored();\n                }\n            }\n\n            protected parsePattern(pattern: Types.Pattern, parentRule?: Types.Rule): Result {\n                this.lastHandledRule = pattern.type;\n\n                if (this.depth > this.settings.maxDepth!) {\n                    throw new Error('Maximum parsing depth exceeded');\n                }\n\n                // Better silent context management\n                const shouldBeSilent = this.shouldBeSilent(pattern, parentRule);\n\n                // For optional patterns, we need special handling\n                const isOptionalContext = parentRule?.name === 'optional' ||\n                                        this.patternStack[this.patternStack.length - 1] === 'optional';\n\n                this.silentContextStack.push(shouldBeSilent || isOptionalContext);\n\n                const startIndex = this.index;\n                const memoKey = this.shouldUseMemoization(pattern, parentRule)\n                    ? this.createMemoKey(pattern, startIndex, parentRule?.name)\n                    : null;\n\n                // Check memoization\n                if (memoKey) {\n                    const memoResult = this.getMemoized(memoKey);\n                    if (memoResult.hit) {\n                        this.index = memoResult.newIndex!;\n                        this.silentContextStack.pop();\n                        this.log('verbose', `🔋 Memo HIT: ${memoKey} → ${memoResult.newIndex}`);\n                        return memoResult.result!;\n                    }\n                }\n\n                this.indentLevel++;\n                this.log('patterns', `${'  '.repeat(this.indentLevel)}⚡ ${pattern.type}${parentRule ? ` (${parentRule.name})` : ''}${shouldBeSilent ? ' [SILENT]' : ''} @${this.index}`);\n                this.depth++;\n\n                let result = Result.create('unset', null, 'unset', this.getCurrentSpan());\n\n                try {\n                    this.skipIgnored(parentRule?.options?.ignored);\n\n                    result = this.executePattern(pattern, parentRule, shouldBeSilent);\n\n                    const status = result !== null ? '✓' : '✗';\n                    this.log('patterns', `${'  '.repeat(this.indentLevel)}${status} ${pattern.type} → ${this.index}`);\n\n                    // Only memoize if we're not in an error state\n                    if (memoKey && !isOptionalContext) {\n                        this.memoize(memoKey, result, startIndex, this.index);\n                    }\n\n                    return result;\n                } catch (error) {\n                    // In optional context, don't let errors propagate up\n                    if (isOptionalContext) {\n                        this.index = startIndex;\n\n                        this.log('patterns', `${'  '.repeat(this.indentLevel)}✗ ${pattern.type} (optional context, suppressed) → ${startIndex}`);\n\n                        return Result.createAsOptional('failed', null, this.getCurrentSpan());\n                    }\n                    throw error;\n                } finally {\n                    this.depth--;\n                    this.indentLevel--;\n                    this.silentContextStack.pop();\n                }\n            }\n\n            private executePattern(pattern: Types.Pattern, parentRule?: Types.Rule, shouldBeSilent?: boolean): Result {\n                switch (pattern.type) {\n                    case 'token':\n                        return this.parseToken(pattern.name!, pattern.value!, parentRule, shouldBeSilent);\n                    case 'rule':\n                        return this.parseRule(pattern.name!, parentRule, shouldBeSilent);\n                    case 'repeat':\n                        return this.parseRepeat(pattern.pattern!, pattern.min || 0, pattern.max || Infinity, pattern.separator, parentRule, shouldBeSilent);\n                    case 'seq':\n                        return this.parseSequence(pattern.patterns!, parentRule, shouldBeSilent);\n                    case 'choice':\n                        return this.parseChoice(pattern.patterns!, parentRule, shouldBeSilent);\n                    case 'optional':\n                        return this.parseOptional(pattern.pattern!, parentRule);\n                    default:\n                        throw new Error(`Unknown pattern type: ${pattern.type}`);\n                }\n            }\n\n            private parseToken(tokenName: string, tokenValue?: string, parentRule?: Types.Rule, shouldBeSilent?: boolean): Result {\n                this.lastHandledRule = parentRule?.name || tokenName;\n                this.log('tokens', `→ ${tokenName} @${this.index}`);\n                this.lastVisitedIndex = this.index;\n\n                if (this.index >= this.tokens.length) {\n                    this.log('tokens', `✗ Expected '${tokenName}', got 'EOF' @${this.index}`);\n\n                    if (shouldBeSilent) { return Result.create('failed', null, 'unset', this.getCurrentSpan()); }\n\n                    const error = this.createError(\n                        Types.ERRORS.TOKEN_EXPECTED_EOF,\n                        `Expected '${tokenName}', got 'EOF'`,\n                        this.getCurrentSpan(),\n                        0,\n                        this.index,\n                        this.lastHandledRule!,\n                        this.getInnerMostRule()\n                    );\n                    const finalError = this.getCustomErrorOr(parentRule, error);\n                    return Result.createAsToken('failed', null, this.getCurrentSpan()).withError(finalError);\n                }\n\n                const token = this.getCurrentToken();\n\n                if (token.kind === tokenName) {\n                    if(tokenValue && token.value !== tokenValue) {\n                        const error = this.createError(\n                            Types.ERRORS.TOKEN_MISMATCH,\n                            `Expected '${tokenName}' with value '${tokenValue}', got '${token.value}'`,\n                            this.getCurrentSpan(),\n                            0,\n                            this.index,\n                            this.lastHandledRule!,\n                            this.getInnerMostRule()\n                        );\n                        this.handleParseError(error, parentRule);\n                    }\n                    else {\n                        const consumedToken = { ...token };\n                        this.index++;\n                        this.stats.tokensProcessed++;\n                        this.log('tokens', `✓ ${tokenName} = \"${token.value}\" @${this.index - 1}`);\n                        return Result.createAsToken('passed', consumedToken, consumedToken.span);\n                    }\n                }\n\n                this.log('tokens', `✗ Expected '${tokenName}', got '${token.kind}' @${this.lastVisitedIndex}`);\n\n                if (shouldBeSilent) { return Result.create('failed', null, 'unset', token.span); }\n\n                const error = this.createError(\n                    Types.ERRORS.TOKEN_MISMATCH,\n                    `Expected '${tokenName}', got '${token.kind}'`,\n                    Parser.hanldeErrorSpan(this.getCurrentSpan()),\n                    0,\n                    this.lastVisitedIndex,\n                    this.lastHandledRule!,\n                    this.getInnerMostRule(true)\n                );\n                this.handleParseError(error, parentRule);\n            }\n\n            private parseRule(ruleName: string, parentRule?: Types.Rule, shouldBeSilent?: boolean): Result {\n                this.lastHandledRule = ruleName;\n                this.ruleStack.push(ruleName);\n                this.patternStack.push('rule');\n                this.lastInnerRule = ruleName;\n\n                this.log('rules', `→ ${ruleName} @${this.index} [Stack: ${this.ruleStack.join(' → ')}]`);\n                this.lastVisitedIndex = this.index;\n\n                const targetRule = this.rules.get(ruleName);\n                if (!targetRule) {\n                    this.ruleStack.pop();\n                    this.patternStack.pop();\n                    const error = new Error(`Rule '${ruleName}' not found`);\n                    this.handleFatalError(error);\n                    return Result.create('failed', null, 'unset', this.getCurrentSpan()).withError(this.fetalErrorToParseError(error));\n                }\n\n                const startIndex = this.index;\n                const savedErrors = [...this.errors];\n                const savedSuccessfulRules = [...this.successfulRules];\n\n                try {\n                    this.stats.rulesApplied++;\n\n                    const result = this.parsePattern(targetRule.pattern, targetRule);\n\n                    if (!result.isFullyPassed()) {\n                        this.successfulRules = savedSuccessfulRules;\n\n                        if (shouldBeSilent) {\n                            this.log('rules', `✗ ${ruleName} (silent) @${this.lastVisitedIndex}`);\n                            this.ruleStack.pop();\n                            this.patternStack.pop();\n                            return Result.create('failed', null, 'unset', result.span);\n                        }\n\n                        const error = this.createError(\n                            Types.ERRORS.RULE_FAILED,\n                            `Rule '${ruleName}' failed to match`,\n                            this.getCurrentSpan(),\n                            0,\n                            this.lastVisitedIndex,\n                            this.lastHandledRule!,\n                            this.getInnerMostRule(true)\n                        );\n\n                        this.ruleStack.pop();\n                        this.patternStack.pop();\n                        const finalError = this.getCustomErrorOr(parentRule, error);\n                        return Result.create('failed', null, 'unset', result.span).withError(finalError);\n                    }\n\n                    let finalResult = result;\n                    if (result !== null && targetRule.options?.build) {\n                        const build_result = this.safeBuild(targetRule.options.build, finalResult);\n                        if(build_result) { finalResult = build_result; }\n                    }\n\n                    this.log('rules', `✓ RULE → ${ruleName} @${this.lastVisitedIndex}`);\n\n                    // Track successful completion\n                    this.lastCompletedRule = ruleName;\n                    this.successfulRules.push(ruleName);\n                    this.globalSuccessRules.push(ruleName);\n\n                    this.updateLeafRule(ruleName);\n                    this.trimSuccessfulRules();\n\n                    this.ruleStack.pop();\n                    this.patternStack.pop();\n                    return finalResult;\n\n                } catch (e) {\n                    this.successfulRules = savedSuccessfulRules;\n                    this.ruleStack.pop();\n                    this.patternStack.pop();\n\n                    if (shouldBeSilent) {\n                        this.index = startIndex;\n                        this.errors = savedErrors;\n                        return Result.create('failed', null, 'unset', this.getCurrentSpan());\n                    }\n\n                    if (e instanceof Error) {\n                        this.handleFatalError(e);\n                    } else {\n                        this.handleParseError((e as Types.ParseError), parentRule);\n                    }\n                }\n\n                return Result.create('failed', null, 'unset', this.getCurrentSpan());\n            }\n\n            private parseOptional(pattern: Types.Pattern, parentRule?: Types.Rule): Result {\n                this.log('verbose', `OPTIONAL @${this.index}`);\n\n                this.lastHandledRule  = 'optional';\n                this.lastVisitedIndex = this.index;\n\n                const startIndex  = this.index;\n                const savedErrors = [...this.errors];\n\n                try {\n                    // Parse the pattern - but we need to be more careful about silent mode\n                    const result : Result = this.parsePattern(pattern, parentRule);\n\n                    if (result.isFullyPassed()) {\n                        // Success case - return array with the result\n                        this.log('verbose', `✓ OPTIONAL → [1 element] @${this.index}`);\n\n                        return Result.createAsOptional('passed', result, result.span);\n                    } else {\n                        // Failure case - this is a normal failure for optional\n                        // Reset to start position since we didn't consume anything useful\n                        this.index  = startIndex;\n                        this.errors = savedErrors;\n\n                        this.log('verbose', `✓ OPTIONAL → [] (pattern returned null) @${this.index}`);\n\n                        return Result.createAsOptional('passed', null, result.span ?? this.getCurrentSpan());\n                    }\n                } catch (e) {\n                    this.index  = startIndex;\n                    this.errors = savedErrors;\n\n                    this.log('verbose', `✓ OPTIONAL → [] (exception caught: ${(e as Types.ParseError).msg || e}) @${this.index}`);\n\n                    return Result.createAsOptional('passed', null, this.getCurrentSpan());\n                }\n            }\n\n            private parseChoice(patterns: Types.Pattern[], parentRule?: Types.Rule, shouldBeSilent?: boolean): Result {\n                this.log('verbose', `CHOICE[${patterns.length}] @${this.index}`);\n                this.lastVisitedIndex = this.index;\n\n                const startIndex = this.index;\n                const savedErrors = [...this.errors];\n\n                let bestResult: {\n                    index               : number;\n                    errors              : Types.ParseError[];\n                    span                : Types.Span;\n                    progress            : number;\n                    patternIndex        : number;\n                    failedAt            : number;\n                } | null = null;\n\n                for (let patternIndex = 0; patternIndex < patterns.length; patternIndex++) {\n                    this.index  = startIndex;\n                    this.errors = [...savedErrors];\n\n                    try {\n                        const result = this.parsePattern(patterns[patternIndex], parentRule);\n                        if (result.isFullyPassed()) {\n                            this.log('verbose', `✓ CHOICE → alt ${patternIndex + 1}/${patterns.length} succeeded @${this.lastVisitedIndex}`);\n                            return Result.createAsChoice('passed', result, patternIndex, result.span);\n                        }\n\n                        const progress = this.lastVisitedIndex - startIndex;\n                        const currentErrors = this.errors.slice(savedErrors.length);\n\n                        this.log('verbose', `✗ CHOICE → alt ${patternIndex + 1} failed, errors=${currentErrors.length}, progress=${progress}`);\n\n                        if (!bestResult || progress > bestResult.progress || (progress === bestResult.progress && currentErrors.length > 0)) {\n                            bestResult = {\n                                index       : this.index,\n                                errors      : currentErrors,\n                                span        : this.getCurrentSpan(),\n                                progress,\n                                patternIndex,\n                                failedAt    : -1\n                            };\n                        }\n                    } catch (error: unknown) {\n                        const progress = this.lastVisitedIndex - startIndex;\n                        const normalizedError = this.normalizeError(error, this.getCurrentSpan());\n\n                        this.log('verbose', `✗ CHOICE → alt ${patternIndex + 1} threw error: ${normalizedError.msg}, progress=${progress}`);\n\n                        if (!bestResult || (progress >= bestResult.progress && (error as Types.ParseError).failedAt > bestResult.failedAt)) {\n                            bestResult = {\n                                index       : this.lastVisitedIndex,\n                                errors      : [normalizedError],\n                                span        : normalizedError.span,\n                                progress,\n                                patternIndex,\n                                failedAt    : normalizedError.failedAt || -1\n                            };\n                        }\n                    }\n                }\n\n                // All alternatives failed\n                this.index = startIndex;\n                this.errors = savedErrors;\n\n                if (shouldBeSilent) { return Result.create('failed', null, 'unset', this.getCurrentSpan()); }\n\n                if (bestResult) {\n                    const bestError = bestResult.errors.length > 0\n                        ? bestResult.errors[bestResult.errors.length - 1]\n                        : this.createError(\n                            Types.ERRORS.CHOICE_ALL_FAILED,\n                            `Choice failed at alternative ${this.lastVisitedIndex + 1}`,\n                            bestResult.span,\n                            bestResult.failedAt,\n                            this.lastVisitedIndex,\n                            this.lastHandledRule!\n                        );\n\n                    this.log('verbose', `✗ All alternatives failed. Best: pattern ${this.lastVisitedIndex}, progress ${bestResult.progress}, failedAt ${bestResult.failedAt}, error: ${bestError.msg}`);\n                    throw bestError;\n                }\n\n                const error = this.createError(\n                    Types.ERRORS.CHOICE_ALL_FAILED,\n                    `Expected one of: ${patterns.map(p => this.patternToString(p)).join(', ')}`,\n                    this.getCurrentSpan(),\n                    0,\n                    this.lastVisitedIndex,\n                    this.lastHandledRule!\n                );\n                throw error;\n            }\n\n            private parseRepeat(pattern: Types.Pattern, min = 0, max = Infinity, separator?: Types.Pattern, parentRule?: Types.Rule, shouldBeSilent?: boolean): Result {\n                this.lastHandledRule = pattern.type;\n                this.log('verbose', `REPEAT(${min}-${max}) @${this.index}`);\n                this.lastVisitedIndex = this.index;\n\n                const results : Result[] = [];\n                let consecutiveFailures = 0;\n                const startIndex = this.index;\n\n                while (results.length < max && this.index < this.tokens.length) {\n                    const iterationStart = this.index;\n                    const savedErrors = [...this.errors];\n\n                    try {\n                        const result = this.parsePattern(pattern, parentRule);\n\n                        if (!result.isFullyPassed()) {\n                            this.errors = savedErrors;\n\n                            // Better minimum requirement handling\n                            if (results.length >= min) {\n                                // We have enough results, break cleanly\n                                break;\n                            } else if (shouldBeSilent || pattern.silent) {\n                                // Silent mode - break without error\n                                break;\n                            } else {\n                                // Not enough results and not silent - this is an error\n                                consecutiveFailures++;\n                                if (consecutiveFailures > 3) {break;}\n\n                                // Try recovery if we have a recovery strategy\n                                if (parentRule?.options?.recovery) {\n                                    this.applyRecovery(parentRule, iterationStart);\n                                    if (this.index === iterationStart) {\n                                        this.index++; // Force progress\n                                    }\n                                    continue;\n                                } else {\n                                    // No recovery - break and let minimum check handle the error\n                                    break;\n                                }\n                            }\n                        }\n\n                        consecutiveFailures = 0;\n\n                        results.push(result);\n\n                        if (this.index === iterationStart) {\n                            this.log('verbose', `⚠️ No progress in repeat iteration, breaking @${this.index}`);\n                            break;\n                        }\n\n                        // Handle separator if needed\n                        if (separator && results.length < max && this.index < this.tokens.length) {\n                            const sepStart = this.index;\n                            const sepSavedErrors = [...this.errors];\n\n                            try {\n                                const sepResult = this.parsePattern(separator, undefined);\n                                if (!sepResult.isFullyPassed()) {\n                                    this.index  = sepStart;\n                                    this.errors = sepSavedErrors;\n                                    break;\n                                }\n                            } catch {\n                                this.index  = sepStart;\n                                this.errors = sepSavedErrors;\n                                break;\n                            }\n                        }\n\n                    } catch (e) {\n                        consecutiveFailures++;\n\n                        this.index  = iterationStart;\n                        this.errors = savedErrors;\n\n                        if (shouldBeSilent || results.length >= min) {\n                            break;\n                        }\n\n                        // Let the pattern error propagate up instead of handling it here\n                        // This allows the proper error handling in the calling context\n                        throw e;\n                    }\n                }\n\n                // Check minimum requirement and create appropriate error\n                if (results.length < min) {\n                    if (shouldBeSilent) { return Result.create('failed', null, 'unset', this.getCurrentSpan()); }\n\n                    // Check if we should use a custom error from the parent rule\n                    if (parentRule?.options?.errors) {\n                        const customError = this.getCustomErrorForCondition(parentRule, 0, this.index, startIndex);\n                        if (customError) {\n                            throw customError;\n                        }\n                    }\n\n                    const error = this.createError(\n                        Types.ERRORS.REPEAT_MIN_NOT_MET,\n                        `Expected at least ${min} occurrences, got ${results.length}`,\n                        this.getCurrentSpan(),\n                        0,\n                        this.index,\n                        this.lastHandledRule!\n                    );\n\n                    throw error;\n                }\n\n                this.log('verbose', `REPEAT → [${results.length}] @${this.index}`);\n\n                return Result.createAsRepeat('passed', results, results.length ? {\n                        start: results[0].span.start,\n                        end: results[results.length-1].span.end\n                } : this.getCurrentSpan());\n            }\n\n            private parseSequence(patterns: Types.Pattern[], parentRule?: Types.Rule, shouldBeSilent?: boolean): Result {\n                this.log('verbose', `SEQUENCE[${patterns.length}] @${this.index}`);\n                this.lastVisitedIndex = this.index;\n\n                if (patterns.length === 0) { return Result.create('failed', null, 'unset', this.getCurrentSpan()); }\n\n                const startIndex  = this.index;\n                const savedErrors = [...this.errors];\n                const results: Result[] = [];\n                let lastPatternIndex = 0;\n\n                try {\n                    for (lastPatternIndex = 0; lastPatternIndex < patterns.length; lastPatternIndex++) {\n                        const pattern = patterns[lastPatternIndex];\n                        const beforePatternIndex = this.index;\n\n                        const result = this.parsePattern(pattern, parentRule);\n\n                        // Not isFullyPassed, optional must ignored here.\n                        if (!result.isPassed()) {\n                            if (shouldBeSilent) {\n                                this.index  = startIndex;\n                                this.errors = savedErrors;\n                                return Result.create('failed', null, 'unset', result.span);\n                            }\n\n                            const error = this.createError(\n                                Types.ERRORS.SEQUENCE_FAILED,\n                                `Sequence failed at element ${lastPatternIndex + 1}/${patterns.length}`,\n                                this.getCurrentSpan(),\n                                lastPatternIndex,\n                                this.lastVisitedIndex,\n                                this.lastHandledRule!\n                            );\n\n                            this.handleParseError(error, parentRule);\n                        }\n\n                        results.push(result);\n\n                        if (this.index === beforePatternIndex && !pattern.silent) {\n                            this.log('verbose', `⚠️  No progress at sequence element ${lastPatternIndex} @${this.lastVisitedIndex}`);\n                        }\n\n                        this.skipIgnored(parentRule?.options?.ignored);\n                    }\n\n                    this.log('verbose', `SEQUENCE → [${results.length}] @${this.lastVisitedIndex}`);\n                    return Result.createAsSequence('passed', results, results.length ? {\n                        start: results[0].span.start,\n                        end: results[results.length-1].span.end\n                    } : this.getCurrentSpan());\n\n                } catch (e) {\n                    this.index  = startIndex;\n                    this.errors = savedErrors;\n\n                    if (!shouldBeSilent && !this.isInSilentMode()) {\n                        if (e instanceof Error) {\n                            this.handleFatalError(e);\n                        } else {\n                            const error = this.createError((e as Types.ParseError).code, (e as Types.ParseError).msg, (e as Types.ParseError).span, lastPatternIndex, this.lastVisitedIndex, this.lastHandledRule!);\n                            this.handleParseError(error, parentRule);\n                        }\n                    }\n\n                    return Result.create('failed', null, 'unset', this.getCurrentSpan());\n                }\n            }\n\n            private safeBuild(buildFn: Types.BuildFunction, matches: Result): Result {\n                try {\n                    return buildFn(matches, this);\n                } catch (error) {\n                    // // log if fetal error like : Cannot set properties of undefined (reading/setting 'xxx'), ..\n                    // if(error instanceof TypeError || error instanceof ReferenceError) {\n                    //     console.error(`Build function error in rule '${this.lastHandledRule}':`, error);\n                    // }\n\n                    if (!this.isInSilentMode()) {\n                        const isParseError = (error as Types.ParseError).span !== undefined;\n                        const buildError = this.createError(\n                            isParseError ? (error as Types.ParseError).code : Types.ERRORS.BUILD_FUNCTION_FAILED,\n                            isParseError ? (error as Types.ParseError).msg : `${(error as Error).message}`,\n                            isParseError ? (error as Types.ParseError).span : Parser.hanldeErrorSpan(this.getCurrentSpan()),\n                            isParseError ? (error as Types.ParseError).failedAt : 0,\n                            isParseError ? (error as Types.ParseError).tokenIndex : this.lastVisitedIndex,\n                            isParseError ? (error as Types.ParseError).prevRule : this.lastHandledRule!,\n                            isParseError ? (error as Types.ParseError).prevInnerRule : this.getInnerMostRule(),\n                        );\n                        this.addError(buildError);\n                        this.log('errors', `Build error: ${(error as Error).message}`);\n                    }\n\n                    // NOTE:\n                    // if `matches.status === 'failed'`\n                    // this will stop what I call \"Magnetic bubbles\"\n\n                    // default to returning first match if build fails\n                    return matches;\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MODE ──────────────────────────────┐\n\n            private shouldBeSilent(pattern: Types.Pattern, rule?: Types.Rule): boolean {\n                return rule?.options?.silent === true ||\n                    pattern.silent === true ||\n                    (this.silentContextStack.length > 0 && this.silentContextStack[this.silentContextStack.length - 1]);\n            }\n\n            private isInSilentMode(): boolean {\n                return this.silentContextStack.length > 0 &&\n                    this.silentContextStack[this.silentContextStack.length - 1];\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            private normalizeSettings(settings?: Types.ParserSettings): Types.ParserSettings {\n                const defaultSettings: Types.ParserSettings = {\n                    startRule       : 'root',\n                    errorRecovery   : {\n                        mode        : 'strict',\n                        maxErrors   : 1,\n                    },\n                    ignored         : ['ws'],\n                    debug           : 'off',\n                    maxDepth        : 1000,\n                    maxCacheSize    : 1, // 1 MB\n                };\n\n                if (!settings) {return defaultSettings;}\n\n                const mergedSettings = { ...defaultSettings, ...settings };\n                if (settings?.errorRecovery) {\n                    mergedSettings.errorRecovery = { ...defaultSettings.errorRecovery, ...settings.errorRecovery };\n                }\n\n                return mergedSettings;\n            }\n\n            private validateGrammar(): string[] {\n                const issues: string[] = [];\n                const ruleNames = new Set(Array.from(this.rules.keys()));\n\n                for (const [ruleName, rule] of this.rules) {\n                    const referencedRules = this.extractRuleReferences(rule.pattern);\n                    for (const ref of referencedRules) {\n                        if (!ruleNames.has(ref)) {\n                            issues.push(`Rule '${ruleName}' references undefined rule '${ref}'`);\n                        }\n                    }\n                }\n\n                if (!this.rules.has(this.settings.startRule)) {\n                    issues.push(`Start rule '${this.settings.startRule}' is not defined`);\n                }\n\n                return issues;\n            }\n\n            private extractRuleReferences(pattern: Types.Pattern): string[] {\n                const refs: string[] = [];\n\n                switch (pattern.type) {\n                    case 'rule':\n                        refs.push(pattern.name!);\n                        break;\n                    case 'repeat':\n                        refs.push(...this.extractRuleReferences(pattern.pattern!));\n                        if (pattern.separator) {\n                            refs.push(...this.extractRuleReferences(pattern.separator));\n                        }\n                        break;\n                    case 'optional':\n                        refs.push(...this.extractRuleReferences(pattern.pattern!));\n                        break;\n                    case 'seq':\n                    case 'choice':\n                        if (pattern.patterns) {\n                            for (const p of pattern.patterns) {\n                                refs.push(...this.extractRuleReferences(p));\n                            }\n                        }\n                        break;\n                }\n\n                return refs;\n            }\n\n            private skipIgnored(ruleIgnored?: string[]): void {\n                if (this.ignoredSet.size === 0 && (!ruleIgnored?.length)) {return;}\n\n                const combinedIgnored = ruleIgnored\n                    ? new Set([...this.ignoredSet, ...ruleIgnored])\n                    : this.ignoredSet;\n\n                while (this.index < this.tokens.length) {\n                    const token = this.tokens[this.index];\n                    if (!combinedIgnored.has(token.kind)) {break;}\n                    this.index++;\n                    this.stats.tokensProcessed++;\n                }\n            }\n\n            private skipUntilTokens(tokens: string[]): void {\n                if (tokens.length === 0) {return;}\n\n                const tokenSet = new Set(tokens);\n                const maxIterations = Math.min(10000, this.tokens.length - this.index);\n                let skipped = 0;\n\n                while (this.index < this.tokens.length && skipped < maxIterations) {\n                    const currentToken = this.tokens[this.index];\n\n                    if (tokenSet.has(currentToken.kind)) {\n                        this.log('errors', `Found sync token '${currentToken.kind}' @${this.index}`);\n                        return;\n                    }\n                    this.index++;\n                    skipped++;\n                }\n            }\n\n            private resetState(tokens: Types.Token[]): void {\n                this.tokens = tokens;\n                this.index = 0;\n                this.errors = [];\n                this.ast = [];\n                this.depth = 0;\n                this.errorSeq = 0;\n                this.indentLevel = 0;\n                this.rootStartIndex = 0;\n                this.silentContextStack = [];\n\n                // Reset enhanced rule tracking\n                this.ruleStack = [];\n                this.patternStack = [];\n                this.lastInnerRule = 'unknown';\n                this.lastCompletedRule = 'unknown';\n                this.successfulRules = [];\n                this.globalSuccessRules = [];\n                this.lastLeafRule = 'unknown';\n\n                // Reset memoization\n                this.memoCache.clear();\n                this.memoHits = 0;\n                this.memoMisses = 0;\n\n                this.stats = {\n                    tokensProcessed: 0,\n                    rulesApplied: 0,\n                    errorsRecovered: 0,\n                    parseTimeMs: 0\n                };\n            }\n\n            private getCurrentToken(): Types.Token {\n                return this.tokens[this.index];\n            }\n\n            private getCurrentSpan(): Types.Span {\n                if (this.index === 0) {\n                    if (this.tokens.length > 0) {\n                        return {\n                            start: this.tokens[0].span.start,\n                            end: this.tokens[0].span.end\n                        };\n                    }\n                    return { start: 0, end: 0 };\n                }\n\n                if (this.index >= this.tokens.length) {\n                    const lastToken = this.tokens[this.tokens.length - 1];\n                    return {\n                        start: lastToken.span.start,\n                        end: lastToken.span.end\n                    };\n                }\n\n                return this.tokens[this.index].span;\n            }\n\n            private patternToString(pattern: Types.Pattern): string {\n                switch (pattern.type) {\n                    case 'token'        : return `token(${pattern.name!})`;\n                    case 'rule'         : return `rule(${pattern.name!})`;\n                    case 'repeat'       : return `repeat(${this.patternToString(pattern.pattern!)})`;\n                    case 'optional'     : return `optional(${this.patternToString(pattern.pattern!)})`;\n                    case 'choice'       : return `choice(${pattern.patterns!.map((p: Types.Pattern) => this.patternToString(p)).join('|')})`;\n                    case 'seq'          : return `seq(${pattern.patterns!.map((p: Types.Pattern) => this.patternToString(p)).join(' ')})`;\n                    default             : return pattern.type;\n                }\n            }\n\n            private updateLeafRule(ruleName: string): void {\n                if (ruleName !== 'unknown' &&\n                    !ruleName.includes('<') &&\n                    !ruleName.includes('→') && (ruleName.length < 30)) {\n                    this.lastLeafRule = ruleName;\n                    this.log('verbose', `🍃 Updated lastLeafRule to: \"${ruleName}\"`);\n                }\n            }\n\n            private trimSuccessfulRules(): void {\n                if (this.successfulRules.length > 10) {\n                    this.successfulRules = this.successfulRules.slice(-5);\n                }\n                if (this.globalSuccessRules.length > 20) {\n                    this.globalSuccessRules = this.globalSuccessRules.slice(-10);\n                }\n            }\n\n            isNextToken(type: string, ignoredTokens?: string[]): boolean {\n                const ignored = [...(ignoredTokens ?? []), ...this.settings.ignored!];\n                let currentIndex = this.index;\n\n                while (currentIndex < this.tokens.length) {\n                    const currentToken = this.tokens[currentIndex];\n                    if (currentToken.kind === type) {return true;}\n                    if (ignored.includes(currentToken.kind)) {\n                        currentIndex++;\n                    } else {\n                        break;\n                    }\n                }\n                return false;\n            }\n\n            isPrevToken(type: string, startIndex = -1, ignoredTokens?: string[]): boolean {\n                if (startIndex === -1) {startIndex = this.index > 0 ? this.index : 0;}\n                const ignored = [...(ignoredTokens ?? []), ...this.settings.ignored!];\n                let currentIndex = startIndex - 1;\n\n                while (currentIndex >= 0) {\n                    const currentToken = this.tokens[currentIndex];\n                    if (currentToken.kind === type) {return true;}\n                    if (ignored.includes(currentToken.kind)) {\n                        currentIndex--;\n                    } else {\n                        break;\n                    }\n                }\n                return false;\n            }\n\n            isPrevRule(name: string): boolean {\n                return this.lastHandledRule === name;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────────── ERROR ──────────────────────────────┐\n\n            static hanldeErrorSpan(span: Types.Span) : Types.Span {\n                if(span.start === span.end) { span.end +=1; }\n                return span;\n            }\n\n            private createError(code: string, msg: string, span: Types.Span | undefined, failedAt: number, tokenIndex: number, prevRule: string, prevInnerRule?: string): Types.ParseError {\n                return {\n                    code,\n                    msg,\n                    span: span || this.getCurrentSpan(),\n                    failedAt,\n                    tokenIndex,\n                    startIndex: this.rootStartIndex,  // Use root start index for error tracking\n                    prevRule,\n                    prevInnerRule: prevInnerRule || this.getInnerMostRule()\n                };\n            }\n\n            private getCustomErrorOr(rule: Types.Rule | null | undefined, defaultError: Types.ParseError): Types.ParseError {\n                if (!rule?.options?.errors) {return defaultError;}\n\n                for (const errorHandler of rule.options.errors) {\n                    let matches = false;\n\n                    if (typeof errorHandler.cond === 'number') {\n                        matches = (defaultError.failedAt === errorHandler.cond);\n                    } else if (typeof errorHandler.cond === 'function') {\n                        try {\n                            const contextualInnerRule = this.getInnerMostRule(true);\n\n                            const opt = {\n                                failedAt: defaultError.failedAt,\n                                tokenIndex: defaultError.tokenIndex,\n                                prevRule: defaultError.prevRule,\n                                prevInnerRule: contextualInnerRule\n                            };\n\n                            matches = errorHandler.cond(this, opt);\n                        } catch (err) {\n                            // console.error('Error in condition function:', err);\n                            matches = false;\n                        }\n                    }\n\n                    if (matches) {\n                        return this.createError(\n                            errorHandler.code || Types.ERRORS.CUSTOM_ERROR,\n                            errorHandler.msg,\n                            defaultError.span,\n                            defaultError.failedAt,\n                            defaultError.tokenIndex,\n                            defaultError.prevRule,\n                            defaultError.prevInnerRule || this.getInnerMostRule(true)\n                        );\n                    }\n                }\n\n                return defaultError;\n            }\n\n            private getInnerMostRule(forErrorCondition = false): string {\n                this.log('verbose', `📍 Types.Rule context: stack=[${this.ruleStack.join(',')} as ${this.patternStack.join(',')}], recent=[${this.successfulRules.slice(-3).join(',')}], leaf=${this.lastLeafRule}, current=${this.lastHandledRule}`);\n\n                if (forErrorCondition && this.lastLeafRule !== 'unknown') {\n                    this.log('verbose', `🎯 getInnerMostRule(forErrorCondition=true) using lastLeafRule: \"${this.lastLeafRule}\"`);\n                    return this.lastLeafRule;\n                }\n\n                if (this.ruleStack.length > 0) {\n                    return this.ruleStack[this.ruleStack.length - 1];\n                }\n\n                if (this.lastLeafRule !== 'unknown') {\n                    return this.lastLeafRule;\n                }\n\n                // Look at most recently completed meaningful rule\n                const meaningfulRules = [...this.successfulRules, ...this.globalSuccessRules];\n                for (let i = meaningfulRules.length - 1; i >= 0; i--) {\n                    const rule = meaningfulRules[i];\n                    if (this.isMeaningfulRule(rule)) {\n                        return rule;\n                    }\n                }\n\n                if (this.lastCompletedRule !== 'unknown' && this.lastCompletedRule.length < 30) {\n                    return this.lastCompletedRule;\n                }\n\n                return this.lastInnerRule;\n            }\n\n            private isMeaningfulRule(rule: string): boolean {\n                return rule !== 'unknown' &&\n                    !rule.includes('<') &&\n                    !rule.includes('→') &&\n                    rule.length < 30;\n            }\n\n            private isSpanCovered(inner: Types.Span, outer: Types.Span): boolean {\n                return outer.start <= inner.start && outer.end >= inner.end;\n            }\n\n            private addError(error: Types.ParseError): void {\n                if (this.isInSilentMode()) {return;}\n\n                const maxErrors = this.settings.errorRecovery!.maxErrors!;\n                if (maxErrors !== 0 && this.errors.length >= maxErrors) {return;}\n\n                if (this.settings.errorRecovery!.mode === 'strict' && this.errors.length > 0) {return;}\n\n                // Normalize error message by removing different quote styles\n                const normalizeMsg = (msg: string) =>\n                    msg.replace(/[`'\"]/g, '').toLowerCase();\n\n                // Check for duplicate errors with same code and normalized message\n                const duplicateError = this.errors.find(e =>\n                    e.code === error.code &&\n                    normalizeMsg(e.msg) === normalizeMsg(error.msg)\n                );\n\n                if (duplicateError) {\n                    // If we find a duplicate, always keep the first error (with earlier span)\n                    if (error.span && duplicateError.span) {\n                        // Keep the earlier error by discarding the new one\n                        return;\n                    }\n                }\n\n                // Check for errors with same startIndex and keep only the first one\n                const sameStartIndexError = this.errors.find(e =>\n                    e.startIndex === error.startIndex\n                );\n\n                if (sameStartIndexError) {\n                    // Keep the first error with this startIndex by discarding the new one\n                    return;\n                }\n\n                if (error.span) {\n                    // First check for exact span matches (keeping older ones)\n                    const hasExactSpanMatch = this.errors.some(e =>\n                        e.span && error.span &&\n                        e.span.start === error.span.start &&\n                        e.span.end === error.span.end\n                    );\n\n                    if (hasExactSpanMatch) {\n                        return;\n                    }\n\n                    // Then check if this error's span is covered by any existing error\n                    const isErrorCovered = this.errors.some(e =>\n                        e.span && error.span &&\n                        this.isSpanCovered(error.span, e.span)\n                    );\n\n                    if (isErrorCovered) {\n                        return;\n                    }\n\n                    // Finally, remove any errors whose spans are covered by this error\n                    this.errors = this.errors.filter(e =>\n                        !e.span || !error.span ||\n                        !this.isSpanCovered(e.span, error.span)\n                    );\n                }\n\n                // Add the error and log it\n                this.errors.push(error);\n                this.log('errors', `⚠️  ${error.msg} @${error.span?.start}:${error.span?.end}`);\n            }\n\n            private handleParseError(error: Types.ParseError, rule?: Types.Rule): never {\n                const finalError = this.getCustomErrorOr(rule, error);\n                throw finalError;\n            }\n\n            private handleFatalError(error: unknown): void {\n                const parseError = this.normalizeError(error, this.getCurrentSpan());\n                parseError.prevInnerRule = this.getInnerMostRule();\n                this.addError(parseError);\n                this.log('errors', `💥 Fatal error: ${parseError.msg} @${this.index}`);\n            }\n\n            private fetalErrorToParseError(error: Error): Types.ParseError {\n                return this.createError(\n                    Types.ERRORS.FATAL_ERROR,\n                    error.message,\n                    this.getCurrentSpan(),\n                    0,\n                    this.lastVisitedIndex,\n                    this.lastHandledRule!,\n                    this.getInnerMostRule()\n                );\n            }\n\n            private normalizeError(error: unknown, defaultSpan: Types.Span): Types.ParseError {\n                if (error && typeof error === 'object' && 'msg' in error && 'code' in error && 'span' in error) {\n                    const parseError = error as Types.ParseError;\n                    if (!parseError.prevInnerRule) {\n                        parseError.prevInnerRule = this.getInnerMostRule();\n                    }\n                    return parseError;\n                }\n\n                if (error instanceof Error) {\n                    return this.createError(\n                        Types.ERRORS.FATAL_ERROR,\n                        error.message,\n                        defaultSpan,\n                        0,\n                        this.lastVisitedIndex,\n                        this.lastHandledRule!,\n                        this.getInnerMostRule()\n                    );\n                }\n\n                return this.createError(\n                    Types.ERRORS.UNKNOWN_ERROR,\n                    `Unknown error: ${error}`,\n                    defaultSpan,\n                    0,\n                    this.lastVisitedIndex,\n                    this.lastHandledRule!,\n                    this.getInnerMostRule()\n                );\n            }\n\n            private applyRecovery(rule?: Types.Rule, startIndex?: number): void {\n                const recovery = rule?.options?.recovery;\n\n                if (recovery) {\n                    this.applyRecoveryStrategy(recovery);\n                } else {\n                    // Only apply default recovery if no custom recovery is defined\n                    this.skipIgnored();\n                    if (this.index < this.tokens.length) {\n                        this.index++;\n                    }\n                }\n\n                this.stats.errorsRecovered++;\n\n                // Ensure we make progress\n                if (startIndex !== undefined && this.index === startIndex && this.index < this.tokens.length) {\n                    this.index++;\n                }\n            }\n\n            private getCustomErrorForCondition(rule: Types.Rule, failedAt: number, tokenIndex: number, _startIndex: number): Types.ParseError | null {\n                if (!rule?.options?.errors) {return null;}\n\n                for (const errorHandler of rule.options.errors) {\n                    let matches = false;\n\n                    if (typeof errorHandler.cond === 'number') {\n                        matches = (failedAt === errorHandler.cond);\n                    } else if (typeof errorHandler.cond === 'function') {\n                        try {\n                            const opt = {\n                                failedAt,\n                                tokenIndex,\n                                prevRule: rule.name,\n                                prevInnerRule: this.getInnerMostRule(true)\n                            };\n                            matches = errorHandler.cond(this, opt);\n                        } catch (err) {\n                            // console.error('Error in condition function:', err);\n                            matches = false;\n                        }\n                    }\n\n                    if (matches) {\n                        return this.createError(\n                            errorHandler.code || Types.ERRORS.CUSTOM_ERROR,\n                            errorHandler.msg,\n                            this.getCurrentSpan(),\n                            failedAt,\n                            tokenIndex,\n                            rule.name,\n                            this.getInnerMostRule(true)\n                        );\n                    }\n                }\n\n                return null;\n            }\n\n            private applyRecoveryStrategy(strategy: Types.RecoveryStrategy): void {\n                const beforePos = this.index;\n                this.log('errors', `🔧 Recovery: ${strategy.type} @${beforePos}`);\n\n                switch (strategy.type) {\n                    case 'skipUntil':\n                        { const tokens = strategy.tokens || (strategy.token ? [strategy.token] : []);\n                        this.skipUntilTokens(tokens);\n                        break; }\n                    default:\n                }\n\n                this.log('errors', `Recovery: ${beforePos} → ${this.index}`);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────────── DEBUG ──────────────────────────────┐\n\n            private log(level: Types.DebugLevel, message: string): void {\n                if (this.debugLevel === 'off') {return;}\n\n                const levels: Types.DebugLevel[] = ['off', 'errors', 'rules', 'patterns', 'tokens', 'verbose'];\n                const currentIndex = levels.indexOf(this.debugLevel);\n                const messageIndex = levels.indexOf(level);\n\n                if (messageIndex <= currentIndex) {\n                    const prefix = this.getDebugPrefix(level);\n                }\n            }\n\n            private getDebugPrefix(level: Types.DebugLevel): string {\n                const prefixes: Record<string, string> = {\n                    errors      : '🔥',\n                    rules       : '📋',\n                    patterns    : '🔍',\n                    tokens      : '🎯',\n                    verbose     : '📝'\n                };\n\n                return `[${prefixes[level] || (level === 'off' ? '⚡' : '')}]`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────────── CACHE ──────────────────────────────┐\n\n            public dispose(): void {\n                this.memoCache.clear();\n                this.rules.clear();\n                this.ignoredSet.clear();\n                this.tokens = [];\n                this.ast = [];\n                this.errors = [];\n                this.silentContextStack = [];\n                this.ruleStack = [];\n                this.successfulRules = [];\n                this.globalSuccessRules = [];\n            }\n\n            private cleanMemoCache(): void {\n                const entries = Array.from(this.memoCache.entries());\n                const now = Date.now();\n\n                const validEntries = entries.filter(([, value]) => {\n                    if (now - (value.cachedAt || 0) > 1000) {return false;}\n                    if (value.errorCount !== this.errors.length) {return false;}\n                    return true;\n                });\n\n                const keepCount = Math.floor(validEntries.length / 2);\n                this.memoCache.clear();\n\n                for (let i = validEntries.length - keepCount; i < validEntries.length; i++) {\n                    this.memoCache.set(validEntries[i][0], validEntries[i][1]);\n                }\n\n                this.log('verbose', `🧹 Memo cache cleaned: kept ${keepCount} of ${entries.length} entries`);\n            }\n\n            private createMemoKey(pattern: Types.Pattern, position: number, ruleName?: string): string {\n                const silentContext = this.isInSilentMode() ? 'S' : 'L';\n                const errorContext = this.errors.length > 0 ? `E${this.errors.length}` : 'E0';\n\n                const baseKey = `${pattern.type}:${position}:${silentContext}:${errorContext}`;\n\n                if (ruleName) {\n                    const rule = this.rules.get(ruleName);\n                    const ruleContext = this.getRuleContext(rule);\n                    return `rule:${ruleName}:${ruleContext}:${baseKey}`;\n                }\n\n                switch (pattern.type) {\n                    case 'token':\n                        return `${baseKey}:${pattern.name}:${pattern.value || ''}`;\n                    case 'optional':\n                        return `${baseKey}:optional`;\n                    case 'repeat':\n                        return `${baseKey}:${pattern.min || 0}:${pattern.max || 'inf'}:${pattern.separator ? 'sep' : 'nosep'}`;\n                    case 'seq':\n                    case 'choice':\n                        { const patternHash = this.hashPatterns(pattern.patterns || []);\n                        return `${baseKey}:${pattern.patterns?.length || 0}:${patternHash}`; }\n                    default:\n                        return baseKey;\n                }\n            }\n\n            private getRuleContext(rule?: Types.Rule): string {\n                if (!rule) {return 'none';}\n\n                const hasBuilder = rule.options?.build ? 'B' : '';\n                const hasErrors = rule.options?.errors?.length ? 'E' : '';\n                const hasRecovery = rule.options?.recovery ? 'R' : '';\n                const isSilent = rule.options?.silent ? 'S' : '';\n\n                return `${hasBuilder}${hasErrors}${hasRecovery}${isSilent}`;\n            }\n\n            private hashPatterns(patterns: Types.Pattern[]): string {\n                return patterns.map(p => `${p.type}${p.silent ? 'S' : ''}`).join('');\n            }\n\n            private getMemoized(key: string): Types.MemoEntry {\n                if (!this.settings.maxCacheSize || this.memoCache.size >= this.settings.maxCacheSize) {\n                    return { hit: false };\n                }\n\n                const cached = this.memoCache.get(key);\n                if (cached !== undefined) {\n                    if (this.isCachedResultValid(cached)) {\n                        this.memoHits++;\n                        this.log('verbose', `📋 Memo HIT: ${key} → ${cached.newIndex}`);\n                        return { hit: true, result: cached.result, newIndex: cached.newIndex };\n                    } else {\n                        this.memoCache.delete(key);\n                        this.log('verbose', `🗑️ Memo INVALID: ${key}`);\n                    }\n                }\n\n                this.memoMisses++;\n                return { hit: false };\n            }\n\n            private isCachedResultValid(cached: Types.MemoEntry): boolean {\n                if (typeof cached.newIndex !== 'number' || cached.newIndex < 0) {return false;}\n                if (cached.newIndex > this.tokens.length) {return false;}\n                return true;\n            }\n\n            private memoize(key: string, result: Result, startIndex: number, endIndex: number): void {\n                if (!this.settings.maxCacheSize || this.memoCache.size >= this.settings.maxCacheSize) {return;}\n\n                if (!result.isFullyPassed() && startIndex === endIndex) {\n                    this.log('verbose', `⚠️ Skip memo (no progress): ${key}`);\n                    return;\n                }\n\n                if (this.errors.length > 0 && this.stats.errorsRecovered > 0) {\n                    this.log('verbose', `⚠️ Skip memo (error state): ${key}`);\n                    return;\n                }\n\n                if (this.memoCache.size >= (this.settings.maxCacheSize * 0.9)) {\n                    this.cleanMemoCache();\n                }\n\n                const memoEntry : Types.MemoEntry = {\n                    result          : result.clone(),\n                    newIndex        : endIndex,\n                    cachedAt        : Date.now(),\n                    silentContext   : this.isInSilentMode(),\n                    errorCount      : this.errors.length\n                };\n\n                this.memoCache.set(key, memoEntry);\n                this.log('verbose', `💾 Memo SET: ${key} → ${endIndex}`);\n            }\n\n            private shouldUseMemoization(pattern: Types.Pattern, _parentRule?: Types.Rule): boolean {\n                if (this.stats.errorsRecovered > 0 && this.errors.length > 0) {return false;}\n                if (pattern.type === 'token') {return false;}\n                if (pattern.type === 'rule' && this.isRecursiveContext()) {return false;}\n\n                return pattern.type === 'rule' ||\n                    pattern.type === 'choice' ||\n                    pattern.type === 'seq' ||\n                    pattern.type === 'optional' ||\n                    (pattern.type === 'repeat' && (pattern.min! > 1 || pattern.max! > 1));\n            }\n\n            private isRecursiveContext(): boolean {\n                return this.depth > 10;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// parser.ts — A mechanism for creating grammatical rules.\n//\n// repo   : https://github.com/je-es/parser\n// author : https://github.com/maysara-elshewehy\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as Types           from './types';\n    import * as core            from './core';\n\n    export { Parser }           from './core';\n    export { Result }           from './result';\n    export type {\n        Span,\n        Token,\n        MiniToken,\n        Pattern,\n        Rule,\n        Rules,\n        ErrorHandler,\n        RecoveryStrategy,\n        BuildFunction,\n        ParseResult,\n        ParserSettings,\n        ParseError,\n        DebugLevel,\n    }                           from './types';\n    export { ERRORS }           from './types';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ MAIN ════════════════════════════════════════╗\n\n    // ┌──────────────────────────────── BASE ──────────────────────────────┐\n\n        export function parse(tokens: Types.Token[], rules: Types.Rules, settings?: Types.ParserSettings): Types.ParseResult {\n            const parser = new core.Parser(rules, settings);\n            try {\n                return parser.parse(tokens);\n            } finally {\n                parser.dispose();\n            }\n        }\n\n        export const createRule = ( name: string, pattern: Types.Pattern, options: Types.Rule['options'] = {} ): Types.Rule => {\n            const finalOptions = { name: false, ...options, };\n            return { name, pattern: pattern, options: finalOptions, };\n        };\n\n    // └────────────────────────────────────────────────────────────────────┘\n\n\n    // ┌──────────────────────────────── CTRL ──────────────────────────────┐\n\n        export function token(name: string, value?: string): Types.Pattern {\n            if (!name || typeof name !== 'string') {\n                throw new Error('Token name must be a non-empty string');\n            }\n            return { type: 'token', name, value, silent: false };\n        }\n\n        export function optional(pattern: Types.Pattern): Types.Pattern {\n            if (!pattern || typeof pattern !== 'object') {\n                throw new Error('Optional pattern must be a valid pattern');\n            }\n            return { type: 'optional', pattern, silent: false };\n        }\n\n        export function choice(...patterns: Types.Pattern[]): Types.Pattern {\n            if (patterns.length === 0) {\n                throw new Error('Choice must have at least one pattern');\n            }\n            return { type: 'choice', patterns, silent: false };\n        }\n\n        export function repeat(pattern: Types.Pattern, min = 0, max = Infinity, separator?: Types.Pattern): Types.Pattern {\n            if (min < 0) {\n                throw new Error('Minimum repetition count cannot be negative');\n            }\n            if (max < min) {\n                throw new Error('Maximum repetition count cannot be less than minimum');\n            }\n            return { type: 'repeat', pattern, min, max, separator, silent: false };\n        }\n\n        export function oneOrMore(pattern: Types.Pattern, separator?: Types.Pattern): Types.Pattern {\n            return repeat(pattern, 1, Infinity, separator);\n        }\n\n        export function zeroOrMore(pattern: Types.Pattern, separator?: Types.Pattern): Types.Pattern {\n            return repeat(pattern, 0, Infinity, separator);\n        }\n\n        export function zeroOrOne(pattern: Types.Pattern, separator?: Types.Pattern): Types.Pattern {\n            return silent(repeat(pattern, 0, 1, separator));\n        }\n\n        export function seq(...patterns: Types.Pattern[]): Types.Pattern {\n            if (patterns.length === 0) {\n                throw new Error('Sequence must have at least one pattern');\n            }\n            return { type: 'seq', patterns, silent: false };\n        }\n\n        export function rule(name: string): Types.Pattern {\n            if (!name || typeof name !== 'string') {\n                throw new Error('Rule name must be a non-empty string');\n            }\n            return { type: 'rule', name, silent: false };\n        }\n\n        export function silent<T extends Types.Pattern>(pattern: T): T {\n            return { ...pattern, silent: true };\n        }\n\n        export function loud<T extends Types.Pattern>(pattern: T): T {\n            return { ...pattern, silent: false };\n        }\n\n    // └────────────────────────────────────────────────────────────────────┘\n\n\n    // ┌─────────────────────────────── ERRORS ─────────────────────────────┐\n\n        export function error(cond: Types.ErrorHandler['cond'], msg: string, code?: string): Types.ErrorHandler {\n            return { cond, msg, code: code ?? Types.ERRORS.RECOVERY_CUSTOM };\n        }\n\n        export const errorRecoveryStrategies = {\n            skipUntil(tokens: string | string[]): Types.RecoveryStrategy {\n                return { type: 'skipUntil', tokens: Array.isArray(tokens) ? tokens : [tokens] };\n            },\n        };\n\n    // └────────────────────────────────────────────────────────────────────┘\n\n\n    // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n    // └────────────────────────────────────────────────────────────────────┘\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝"],"mappings":"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","names":["rule","token","error","__spreadValues","lexer"]}