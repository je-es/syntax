{"version":3,"sources":["../lib/syntax.ts"],"sourcesContent":["// syntax.ts — Unified wrapper that streamlines syntax creation\n//             with integrated lexer-parser coordination, LSP support,\n//             and enhanced linting capabilities.\n//\n// repo   : https://github.com/je-es/syntax\n// author : https://github.com/maysara-elshewehy\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as lexer  from '@je-es/lexer';\n    import * as parser from '@je-es/parser';\n\n    export * as lexer  from '@je-es/lexer';\n    export * as parser from '@je-es/parser';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export interface SyntaxConfig {\n        name        : string;\n        version     : string;\n        lexer       : lexer.Rules;\n        parser      : parser.Types.Rule[];\n        settings    : parser.Types.ParserSettings;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Represents a syntax with its lexer, parser, and settings.\n    */\n    export class Syntax {\n        public config: SyntaxConfig;\n        public parser: parser.Parser;\n\n        constructor(config: SyntaxConfig) {\n            this.config = config;\n            this.parser = new parser.Parser(config.parser, config.settings);\n        }\n\n        /**\n         * Parse a given input string into a structured syntax tree using the\n         * syntax's parser.\n         *\n         * @param input - The string to parse.\n         * @returns The parse result, including the syntax tree and any errors.\n         */\n        parse(input: string): parser.Types.ParseResult {\n            const tokens = lexer.tokenize(input, this.config.lexer);\n            return this.parser.parse(tokens);\n        }\n\n        /**\n         * Similar to parse, but returns only the errors in the parse result.\n         *\n         * @param input - The string to lint.\n         * @returns An array of errors found in the input string.\n         */\n        lint(input: string): parser.Types.ParseError[] {\n            const tokens = lexer.tokenize(input, this.config.lexer);\n            return this.parser.parse(tokens).errors;\n        }\n\n        /**\n         * Create a new Syntax object with the given start rule and debug level,\n         * using the current syntax's configuration.\n         *\n         * @param ruleName  - The start rule for the new syntax.\n         * @param debug     - The debug level for the new syntax. If null, the debug level\n         *                    from the current syntax's settings will be used.\n         * @returns A new Syntax object with the given start rule and debug level.\n        */\n        from(ruleName: string, debug: parser.Types.DebugLevel | null = null) : Syntax {\n            const newConfig = { ...this.config };\n            if(debug !== null) {\n                newConfig.settings.debug = debug;\n            }\n            newConfig.settings.startRule = ruleName;\n            const newLang = new Syntax(newConfig);\n            return newLang;\n        }\n    }\n\n    /**\n     * Create a new syntax object with the given configuration.\n     *\n     * @param config - The configuration object for the syntax, containing the\n     *                 lexer rules, parser rules, and parser settings.\n     * @returns A new syntax object.\n     */\n    export function create(config: SyntaxConfig): Syntax {\n        return new Syntax(config);\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA,eAAAA;AAAA,EAAA,cAAAC;AAAA;AAAA;AAaI,YAAwB;AACxB,aAAwB;AAExB,IAAAD,SAAwB;AACxB,IAAAC,UAAwB;AAyBjB,IAAM,SAAN,MAAM,QAAO;AAAA,EAIhB,YAAY,QAAsB;AAC9B,SAAK,SAAS;AACd,SAAK,SAAS,IAAW,cAAO,OAAO,QAAQ,OAAO,QAAQ;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,OAAyC;AAC3C,UAAM,SAAe,eAAS,OAAO,KAAK,OAAO,KAAK;AACtD,WAAO,KAAK,OAAO,MAAM,MAAM;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,KAAK,OAA0C;AAC3C,UAAM,SAAe,eAAS,OAAO,KAAK,OAAO,KAAK;AACtD,WAAO,KAAK,OAAO,MAAM,MAAM,EAAE;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,KAAK,UAAkB,QAAwC,MAAe;AAC1E,UAAM,YAAY,mBAAK,KAAK;AAC5B,QAAG,UAAU,MAAM;AACf,gBAAU,SAAS,QAAQ;AAAA,IAC/B;AACA,cAAU,SAAS,YAAY;AAC/B,UAAM,UAAU,IAAI,QAAO,SAAS;AACpC,WAAO;AAAA,EACX;AACJ;AASO,SAAS,OAAO,QAA8B;AACjD,SAAO,IAAI,OAAO,MAAM;AAC5B;","names":["lexer","parser"]}